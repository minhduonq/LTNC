Phan A.Bai1.Nhan xet:xval và yval có cùng địa chỉ, x và y có cùng địa chỉ.Giải thích:Khi gọi hàm f, compiler cấp địa chỉ cho xval trc, rồi cấp d/c cho x ngay sau đó.Sau khi kết thúc hàm f, xval và x bị xóa khỏi vùng d/c đã cấpKhi gọi hàm f, compiler cấp d/c cho yval vào địa chỉ đã cấp cho xval, rồi cấp d/c cho y ngay sau đó.Do đó, xval và yval có cùng d/c, x & y cũng vậy.Bai2.a,0x61fe14 : a0x61fe15 : b0x61fe16 : cb,0x61fe00 : 10x61fe04 : 20x61fe08 : 30x61fe0c : 40x61fe10 : 5c,0x61fdf0 : 1.20x61fdf8 : 2.40x61fe00 : 3.30x61fe08 : 4.30x61fe10 : 5d,0x61fdf0 : 1.20x61fe00 : 3.30x61fe10 : 50x61fe20 : 3.37031e-317Bai 3.Sua: swap_pointers(&s1, &s2);Giải thích:Phải truyền tham chiếu.Bài4.int main()  {    char *s;    char foo[] = "Hello World";    s = foo;    printf("s is %s\n",s);    s = foo;    printf("s[0] is %s\n",s[0]);    return(0); }Phần C.a.int tinhdodai(char *str) {    int dodai= 0;    while(*str != '\0') {        dodai++;        str++;    }    return dodai}void reverse(char a[]) {    char *start = a;    char *end = a + dodai(a) - 1;    while(start < end) {        char temp = *start;        *start = *end;        *end = temp;        start++;        end--;    }}Vi du:#include<iostream>using namespace std;int tinhdodai(char *str) {    int dodai= 0;    while(*str != '\0') {        dodai++;        str++;    }    return dodai;}void reverse(char a[]) {    char *start = a;    char *end = a + tinhdodai(a) - 1;    while(start < end) {        char temp = *start;        *start = *end;        *end = temp;        start++;        end--;    }}int main() {   char m[] = "VNU";   reverse(m);   cout << m;}------UNVb,#include <stdio.h>void delete_char(char a[], char c) {    int i = 0, j = 0;    while(a[i] != '\0') {        if(a[i] != c) {            a[j] = a[i];            j++;        }        i++;    }    a[j] = '\0';}int main() {    char str[] = "Viet Nam National University ";    printf("Original string: %s\n", str);    delete_char(str, 'l');    printf("String after removing 'l': %s\n", str);    return 0;}c.void pad_right(char a[], int n){  char *ptr = a;  while (*ptr != '\0') {    ptr++;  }  int len = ptr - a;  if(len > n) return ;  ptr = len +a;  while(len < n) {    *ptr = ' ';    ptr++;    len++;  }  *ptr = '\0';}int main() {   char a[] = "abcdef";   int n; cin >> n;   pad_right(a, n);   for(int i = 0; i < tinhdodai(a); i++) {    cout << a[i] << " ;" << endl;   }    return 0;}demo với n = 9, kết quả :a ;b ;c ;d ;e ;f ;  ; ;---d,void pad_left(char a[], int n) {    char *ptr = a;    while (*ptr != '\0') {        ptr++;    }    int len = ptr - a;    if (len >= n) return;    ptr = a + len;    while (ptr >= a) {        *(ptr + n - len) = *ptr;        ptr--;    }    ptr = a;    while (len < n) {        *ptr = ' ';        ptr++;        len++;    }}e,void truncate(char a[], int n) {    char *ptr = a;    while (*ptr != '\0') {        ptr++;    }    int len = ptr - a;    if (len <= n) return;     ptr = a + n;    *ptr = '\0'; }f.bool is_palindrome(char a[]) {    char *ptr = a;    while (*ptr != '\0') {        ptr++;    }    int len = ptr - a;    ptr--; // trỏ đến kí tự cuối cùng của chuỗi a    char *ptt = a;    while(len > 0) {        if(*ptr != *ptt) {            return false;        }        ptr--;        ptt++;        len--;    }    return true;}
